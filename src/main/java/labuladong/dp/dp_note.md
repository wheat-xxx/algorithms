动态规划的一般问题形式就是求最值；

求解dp的核心问题就是穷举；

dp三要素：
- 状态转移方程：递推关系
  - f(n) = f(n - 1) + f(n - 2): 把参数 n 想做一个状态，这个状态 n 是由状态 n - 1 和状态 n - 2 转移（相加）而来，这就叫状态转移
- 最优子结构：是否可以通过子问题的最值得到原问题的最值；
- 重叠子问题：dp数组 空间换时间

# dp框架

明确base case -> 明确状态 -> 明确选择 -> 定义dp数组/函数的含义

- 自顶向下递归的动态规划
- 自底向上迭代的动态规划

---

但凡遇到递归的问题，最好都画出递归树，这对分析算法的复杂度，寻找算法低效的原因都有巨大的帮助；

递归算法的时间复杂度怎么计算？
- 就是用子问题个数乘以解决一个子问题需要的时间。

只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已

计算机解决问题就是通过穷举：
- 算法设计：如何穷举 -> 如何聪明的穷举
- 如何穷举？状态转移方程。难的点在于递归实现以及解空间复杂
- memo、dp_table，空间换时间，聪明的穷举

动态规划通用技巧：数学归纳思想

动态规划找状态转移方程的步骤：
1. 明确dp数组的定义。很重要
2. 根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]

原问题的解是否可以通过子问题的最优解得到？是否具有重叠子问题？如果是的话就是动态规划问题；

dp数组大小的设置

dp数组的遍历方向
- 遍历的过程中，所需的状态必须是已经计算出来的
- 遍历结束后，存储结果的那个位置必须已经被计算出来

## base case和dp table的初始值怎么定？

## 动态规划和回溯算法的思维转换？

---

动态规划 - 空间压缩技巧
- 观察状态转移方程，如果计算状态 dp[i][j] 需要的都是 dp[i][j] 相邻的状态，就可以使用空间压缩技巧，将二维的 dp 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。

