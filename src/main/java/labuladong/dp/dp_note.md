# 动态规划

数学归纳法

动态规划的一般问题形式就是求最值

原问题的解是否可以通过子问题的最优解得到？是否具有重叠子问题？

- 如果是，就是动态规划问题

求解dp的核心问题就是穷举，dp难的就是穷举所有可行解，dp就是暴力解法，只不过可以通过记录子问题答案，避免重复计算

只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已

dp三要素：

- 状态转移方程：
  - 目的是为了完整的穷举，不漏解
  - dp(i)的定义是什么？
  - 假设知道dp(i-1)....dp(0)，dp(i)如何由dp(i-1)....dp(0)转移而来？
- 最优子结构：是否可以通过子问题的最值得到原问题的最值？数学归纳法
  - 子问题间必须相互独立
- 重叠子问题：dp[] memo[] 空间换时间

-----------

# dp框架

base case -> 状态 -> 选择 -> 定义dp数组/函数的含义

- 自顶向下递归的动态规划 - dp()
- 自底向上迭代的动态规划 - dp[]

~~~python
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
~~~

动态规划找状态转移方程的步骤：

1. 明确 dp 数组的定义。很重要
2. 根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]

---------

# 重叠子问题

但凡遇到递归的问题，必须画出递归树，这对分析算法的复杂度，寻找算法低效的原因都有巨大的帮助

递归算法的时间复杂度怎么计算？

- 子问题个数乘以解决一个子问题需要的时间。递归树（决策树）中的节点个数

----------

# 最优子结构

最优子结构：子问题间必须相互独立

1. 状态是什么？
   - 原问题和子问题中会变化的量
2. 选择是什么？
   - 导致状态产生变化的行为
3. 明确dp函数/数组的定义

------------

# 状态转移方程

最长递增子序列问题

- dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度

重要的的是dp[i]的定义，有的dp[i]定义就是题目需要的最值。有的则是以nums[i]结尾的最值，最后需要遍历整个dp数组得到答案

-------

# base case 和 dp[]初始值

dp[]大小的设置 n or n + 1

dp[]边界值的初始化

对于索引越界的值，返回一个不可能取到的值（min or max的过程中会自动排除掉非法索引）

dp数组的遍历方向

1. 遍历的过程中，所需的状态必须是已经计算出来的
2. 遍历结束后，存储结果的那个位置必须被计算出来

---------

# 动态规划 - 空间压缩技巧

观察状态转移方程，如果计算状态 dp[i][j] 需要的都是 dp[i][j] 相邻的状态，就可以使用空间压缩技巧，将二维的 dp 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。

